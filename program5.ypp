/*
program5.ypp
COSC4785
Tyler O'Dowd
10/24/22

This is the input into the bison scanner to build a grammer tree from input
*/

%{
#include<FlexLexer.h>
#include<iostream>
using std::cerr;
using std::cout;
using std::endl;

#include "nodes.hpp"
#include "program5.hpp"
#include "SymbolTable.hpp"
#include "Entry.hpp"

extern Node* tree;
extern SymbolTable* root;
extern yyFlexLexer scanner;
extern int line;
#define yylex() scanner.yylex()

extern int col;
extern string err;
string errType;
extern SymbolTable* super;
extern SymbolTable* table;
extern SymbolTable* cnstr;
extern Entry* symbol;
extern Entry* func;
extern Type* prms;

void yyerror(const char*);

void printError(string msg) {
	cerr<<line<<": "<</*errorLine<<*/"\n"<<msg<<endl;
}

//returns the child error node, or self
Node* errorCheck(Node* n) {
//cerr<<n->getString()<<endl;
	Node* r;
	if((r=n->getLeft())&&(r->isErr())) {
		delete n;
		return r;
	}
	if((r=n->getRight())&&(r->isErr())) {
		delete n;
		return r;
	}
	if((r=n->getMid())&&(r->isErr())) {
		delete n;
		return r;
	}
	if((r=n->getLast())&&(r->isErr())) {
		delete n;
		return r;
	}
	if((r=n->getNext())&&(r->isErr())) {
		delete n;
		return r;
	}
	return n;
}

%}

%union {
  Node* ttype;
}
%define parse.error verbose
%token<ttype> INT IDENT
%token LPAREN RBRACK LBRACE RBRACE
%token ASSIGN COMMA DOT WHILE IF VOID NUL INTTYPE CLASS NEW THIS
%precedence RPAREN
%precedence ELSE
%token PRINT READ RETURN
%left NEQ EQ LEQ GEQ LT GT
%left PLUS MINUS OR
%left TIMES DIV MOD AND
%token LBRACK
%precedence UMINUS
%token SEMI NOT
%type<ttype> program vardec name type arglst cndtlstmt arglst2
%type<ttype> newexp id classdec vardecs optlexp
%type<ttype> constructdecs methoddecs constructdec methoddec classbody
%type<ttype> paramlist param block paramlist2 localvardecs
%type<ttype> stmts localvardec stmt bracketexps bracketexp multibracket
%type<ttype> exp multibrackets classstart

%%


program: classdec {
		tree=new Node($1);
		tree->set("<program> -> <classDeclaration>");
		$$=errorCheck($$);
	}
	| program classdec {
		$1->setNext(new Node($2));
		$1->getNext()->set("<program> -> <program> <classDec>");
		$$=errorCheck($$);
	}
	| error {
		if(tree==nullptr) {
			tree=new NodeERROR();
		}
		$$=new NodeERROR();
	}
;

classdec: classstart classbody {
		$$=$1;
		$1->setRight($2);
		$$=errorCheck($$);
	}
;

classstart: CLASS id LBRACE {
		$$=new Node($2);
		$$->set("<classDeclaration> -> CLASS ID <classBody>");
		$$->table=table;
    super->insert(table->id, table);
    super=table;
    symbol=nullptr;
    table=nullptr;
		$$=errorCheck($$);
	}
	| error id LBRACE {
		printError("Expected \'class\'");
		$$=new NodeERROR();
	}
	| CLASS id error {
		printError("Expected \'{\'");
		$$=new NodeERROR();
	}
;

classbody: RBRACE {
		$$=new Node();
		$$->set("<classBody> -> LBRACE RBRACE");
		$$=errorCheck($$);
		super=super->parent;
	}
	| vardecs constructdecs methoddecs RBRACE {
		$$=new Node($1, $3, $2);
		string str="<classBody> -> LBRACE <varDeclaration> ";
		str+="<constructorDeclaration> <MethodDeclaration> RBRACE";
		$$->set(str);
		super=super->parent;
		$$=errorCheck($$);
	}
	| constructdecs methoddecs RBRACE {
		$$=new Node($1, $2);
		string str="<classBody> -> LBRACE ";
		str+="<constructorDeclaration> <MethodDeclaration> RBRACE";
		$$->set(str);
		super=super->parent;
		$$=errorCheck($$);
	}
	| vardecs methoddecs RBRACE {
		$$=new Node($1, $2);
		string str="<classBody> -> LBRACE <varDeclaration>";
		str+=" <MethodDeclaration> RBRACE";
		$$->set(str);
		super=super->parent;
		$$=errorCheck($$);
	}
	| vardecs constructdecs RBRACE {
		$$=new Node($1, $2);
		string str="<classBody> -> LBRACE <varDeclaration> ";
		str+="<constructorDeclaration> RBRACE";
		$$->set(str);
		super=super->parent;
		$$=errorCheck($$);
	}
	| vardecs RBRACE {
		$$=new Node($1);
		$$->set("<classBody> -> LBRACE <varDeclaration> RBRACE");
		super=super->parent;
		$$=errorCheck($$);
	}
	| constructdecs RBRACE {
		$$=new Node($1);
		$$->set("<classBody> -> LBRACE <constructorDeclaration> RBRACE");
		super=super->parent;
		$$=errorCheck($$);
	}
	| methoddecs RBRACE {
		$$=new Node($1);
		$$->set("<classBody> -> LBRACE <MethodDeclaration> RBRACE");
		super=super->parent;
		$$=errorCheck($$);
	}
	| vardecs error {
		printError("Expected \'}\'");
		$$=new NodeERROR();
	}
;

vardecs: vardecs vardec {
		$1->setNext($2);

	}
	| vardec {
		$$=$1;
	}
;
vardec: type id SEMI {
		$$=new Node($1, $2);
		super->insert(symbol->id, symbol);
		//clear the symbol after insertion to table
		symbol=nullptr;
		table=nullptr;
		$$->set("<varDeclaration> -> <type> ID SEMI");
		$$=errorCheck($$);
	}
  | type multibrackets id SEMI {
		//$$=new Node($1, $3, $2); /*IF NOT WORK FIX*/
		$$=new Node($1, $2);
		super->insert(symbol->id, symbol);
		//clear the symbol after insertion to table
		symbol=nullptr;
		table=nullptr;
		$$->set("<varDeclaration> -> <type> <multibrackets> ID SEMI");
		$$=errorCheck($$);
	}
;

constructdecs: constructdecs constructdec {
		$1->setNext($2);
	}
	| constructdec {
		$$=$1;
	}
;
constructdec: id LPAREN paramlist block {
		$$=new Node($1, $4, $3);
		string str="<constructorDeclaration> -> ID LPAREN <paramList> RPAREN";
		str+=" <block>";
		$$->set(str);
		$$->table=table;
		table->type=prms;
		super->insert(table->id, table);
		table=nullptr;
		prms=nullptr;
		symbol=nullptr;
		$$=errorCheck($$);
	}
	| id error paramlist RPAREN block {
		printError("Expected \'(\'");
		$$=new NodeERROR();
	}
;

methoddecs: methoddecs methoddec {
		$1->setNext($2);
	}
	| methoddec {
		$$=$1;
	}
;

methoddec: type constructdec {
		$$=$2;
		Node* left=$$->getLeft();
		Node* mid=$$->getMid();
		Node* right=$$->getRight();
		$$->setLeft($1);
		$$->setMid(left);
		$$->setRight(mid);
		$$->setLast(right);
		string str="<methodDeclaration> -> <resultType> ID LPAREN <paramList>";
		str+=" RPAREN <block>";
		$$->set(str);
		$$=errorCheck($$);
  }
  | VOID constructdec {
		$$=$2;
		Node* left=$$->getLeft();
		Node* mid=$$->getMid();
		Node* right=$$->getRight();
		$$->setLeft(new Node());
		string str="<resultType> -> VOID";
		$$->getLeft()->set(str);
		$$->setMid(left);
		$$->setRight(mid);
		$$->setLast(right);
		str="<methodDeclaration> -> <resultType> ID LPAREN <paramList>";
		str+=" RPAREN <block>";
		$$->set(str);
		$$=errorCheck($$);
  }
;

paramlist: paramlist2 RPAREN {
		$$=$1;
	}
	| RPAREN {
		$$=new Node();
		prms=new Type();
		$$->set("<parameterList> -> EMPTYSTRING");
	}
;
paramlist2: paramlist2 COMMA param {
		string tmp=$1->getString();
		tmp+=" COMMA <parameter>";
		$1->set(tmp);
		Node* p=$1->getLeft();
		if(p->getNext()) {
			p->getNext();//this could be nullptr hence the if
			while(p->getNext()) {
				p=p->getNext();
			}
			p->setNext($3);
		}
		else {
			p->setNext($3);
		}
		prms->addParam(symbol);
		symbol=nullptr;
		//$$=errorCheck($$); //why wasnt this here before???
	}
	| param {
		$$=new Node($1);
		$$->set("<parameterList> -> <parameter>");
		if(prms) {
      //already exists from method
		}
		else {
      prms=new Type();
		}
		prms->addParam(symbol);
		symbol=nullptr;
		$$=errorCheck($$);
	}
	| paramlist2 error param {
		printError("Expected \',\'");
		$$=new NodeERROR();
	}
;
param: type id {
/*      if(table->type) {
        table->type->addParam(symbol);
        symbol=nullptr;
      }
      else {
        table->type=new Type();
        table->type->addParam(symbol);
        symbol=nullptr;
      }*/
/*    if(prms) {
      //prms->addParam(new Entry($2->entry->id, $1->entry->id));
      symbol=new Entry();
      symbol->type=$1->entry->id;
      symbol->id=$2->entry->id;
      prms->addParam(symbol);
      symbol=nullptr;
    }
    else {
      prms=new Type();
      symbol=new Entry();
      symbol->type=$1->entry->id;
      symbol->id=$2->entry->id;
      prms->addParam(symbol);
      symbol=nullptr;
      //prms->addParam(new Entry($2->entry->id, $1->entry->id));
    }*/
		$$=new Node($1, $2);
		$$->set("<parameter> -> <type> ID");
		$$=errorCheck($$);
	}
;

block: LBRACE localvardecs stmts RBRACE {
		$$=new Node($2, $3);
		$$->set("<block> -> LBRACE <localVarDeclaration>+ <statement>+ RBRACE");
/*		$$->table=cnstr;
		cnstr=nullptr;
		super=super->parent;*/
		$$=errorCheck($$);
	}
	| LBRACE localvardecs RBRACE {
		$$=new Node($2);
		$$->set("<block> -> LBRACE <localVarDeclaration>+ RBRACE");
		$$->table=cnstr;
/*		cnstr=nullptr;
		super=super->parent;*/
		$$=errorCheck($$);
	}
	| LBRACE stmts RBRACE {
		$$=new Node($2);
		$$->set("<block> -> LBRACE <statement>+ RBRACE");
		$$->table=cnstr;
/*		cnstr=nullptr;
		super=super->parent;*/
		$$=errorCheck($$);
	}
	| LBRACE RBRACE {
		$$=new Node();
		$$->set("<block> -> LBRACE RBRACE");
/*		$$->table=new SymbolTable(super);
		cnstr=nullptr;*/
		$$=errorCheck($$);
	}
	| error localvardecs stmts RBRACE {
		printError("Expected \'{\'");
		$$=new NodeERROR();
	}
	| error localvardecs RBRACE {
		printError("Expected \'{\'");
		$$=new NodeERROR();
	}
	| error RBRACE {
		printError("Expected \'{\'");
		$$=new NodeERROR();
	}
;

localvardecs: localvardecs localvardec {
		Node* p=$1;
		if(p->getNext()) {
			p->getNext();//this could be nullptr hence the if
			while(p->getNext()) {
				p=p->getNext();
			}
			p->setNext($2);
		}
		else {
			p->setNext($2);
		}
	}
	| localvardec {
		$$=$1;
	}
;
localvardec: type id SEMI {
		$$=new Node($1, $2);
		$$->set("<localVarDeclaration> -> <type> ID SEMI");
 /*   table->insert(symbol->id, symbol);
    symbol=nullptr;
    if(cnstr) {
      cnstr->insert(symbol->id, symbol);
    }
    else {
      cnstr=new SymbolTable(super);
      super=cnstr;
      cnstr->insert(symbol->id, symbol);
    }*/
		$$=errorCheck($$);
	}
	| type id error {
		printError("Expected \';\'");
		$$=new NodeERROR();
	}
;

stmts: stmts stmt {
		Node* p=$1;
		if(p->getNext()) {
			p->getNext();//this could be nullptr hence the if
			while(p->getNext()) {
				p=p->getNext();
			}
			p->setNext($2);
		}
		else {
			p->setNext($2);
		}
	}
	| stmt {
		$$=$1;
	}
;
stmt: SEMI {
		$$=new Node();
		$$->set("<statement> -> SEMI");
	}
	| name ASSIGN exp SEMI {
		$$=new Node($1, $3);
		$$->set("<statement> -> <name> ASSIGN <expression> SEMI");
		$$=errorCheck($$);
	}
	| name LPAREN arglst RPAREN {
		$$=new Node($1, $3);
		$$->set("<statement> -> <name> LPAREN <argList> SEMI");
		$$=errorCheck($$);
	}
	| PRINT LPAREN arglst RPAREN SEMI {
		$$=new Node($3);
		$$->set("<statement> -> PRINT LPAREN <arglst> RPAREN");
		$$=errorCheck($$);
	}
	| cndtlstmt {
		$$=new Node($1);
		$$->set("<statement> -> <conditionalStatement>");
		super=super->parent;
		$$=errorCheck($$);
	}
	| WHILE LPAREN exp RPAREN stmt {
		$$=new Node($3, $5);
		$$->set("<statement> -> WHILE LPAREN <expression> RPAREN <statement>");
		super=super->parent;
		$$=errorCheck($$);
	}
	| RETURN optlexp SEMI {
		$$=new Node($2);
		$$->set("<statement> -> RETURN <optionalStatement> SEMI");
		$$=errorCheck($$);
	}
	| block {
		$$=new Node($1);
		$$->set("<statement> -> <block>");
		super=super->parent;
		$$=errorCheck($$);
	}
	| error LPAREN arglst RPAREN SEMI {
		printError("Expected \'print\'");
		$$=new NodeERROR();
	}
	| PRINT error arglst RPAREN SEMI {
		printError("Expected \'(\'");
		$$=new NodeERROR();
	}
	| PRINT LPAREN arglst RPAREN error {
		printError("Expected \';\'");
		$$=new NodeERROR();
	}
	| error LPAREN exp RPAREN stmt {
		printError("Expected \'while\'");
		$$=new NodeERROR();
	}
	| WHILE error exp RPAREN stmt {
		printError("Expected \'(\'");
		$$=new NodeERROR();
	}
	| WHILE LPAREN exp error stmt {
		printError("Expected \')\'");
		$$=new NodeERROR();
	}
;

name: THIS {
		$$=new Node();
		$$->set("<name> -> THIS");
	}
	| id {
		$$=new Node($1);
		$$->set("<name> -> ID");
		$$=errorCheck($$);
	}
	| name DOT id {
		$$=new Node($1, $3);
		$$->set("<name> -> <name> DOT ID");
		$$=errorCheck($$);
	}
	| name LBRACK exp RBRACK {
		$$=new Node($1, $3);
		$$->set("<name> -> <name> LBRACK <expression> RBRACK");
		$$=errorCheck($$);
	}
	| name error exp RBRACK {
		printError("Expected \'[\'");
		$$=new NodeERROR();
	}
	| name LBRACK exp error {
		printError("Expected \']\'");
		$$=new NodeERROR();
	}
	| error {
		printError("Expected valid name");
		$$=new NodeERROR();
	}
;

arglst: arglst2 {
		$$=$1;
	}
	| %empty {
		$$=new Node();
		$$->set("<argList> -> EMPTYSTRING");
	}
;
arglst2: arglst2 COMMA exp {
		string tmp=$1->getString();
		tmp+=" COMMA <expression>";
		$1->set(tmp);
		Node* p=$1->getLeft();
		if(p->getNext()) {
			p->getNext();//this could be nullptr hence the if
			while(p->getNext()) {
				p=p->getNext();
			}
			p->setNext($3);
		}
		else {
			p->setNext($3);
		}
	}
	| exp {
		$$=new Node($1);
		$$->set("<argList> -> <expression>");
		$$=errorCheck($$);
	}
	| arglst2 error exp {
		printError("Expected \',\'");
		$$=new NodeERROR();
	}
;
cndtlstmt: IF LPAREN exp RPAREN stmt {
		$$=new Node($3, $5);
		string str="<conditionalStatement> -> IF LPAREN <expression> RPAREN";
		$$->set(str+" <statement>");
		$$=errorCheck($$);
	}
	| IF LPAREN exp RPAREN stmt ELSE stmt {
		$$=new Node($3, $7, $5);
		string str="<conditionalStatement> -> IF LPAREN <expression> RPAREN";
		$$->set(str+" <statement> ELSE <statement>");
		$$=errorCheck($$);
	}
	/*
	| IF LPAREN exp error stmt {
		printError("Expected \')\'");
		$$=new NodeERROR();
	}*/
;

optlexp: %empty {
		$$=new Node();
		$$->set("<optionalExpression> -> EMPTYSTRING");
		$$=errorCheck($$);
	}
	| exp {
		$$=new Node($1);
		$$->set("<optionalExpression -> <exp>");
		$$=errorCheck($$);
	}
;

newexp: NEW id LPAREN arglst RPAREN {
		$$=new Node($2, $4);
		$$->set("<newExpression> -> NEW ID LPAREN <argList> RPAREN");
		$$=errorCheck($$);
	}
	| NEW INTTYPE {
		$$=new Node();
		$$->set("<newExpression> -> NEW <simpleType>");
		$$=errorCheck($$);
	}
	| NEW INTTYPE bracketexps {
		$$=new Node($3);
		string str="<newExpression> -> NEW <simpleType> <LBRACK ";
		$$->set(str+"<expression> RBRACK>+");
		$$=errorCheck($$);
	}
	| NEW id bracketexps {
		$$=new Node($2, $3);
		string str="<newExpression> -> NEW <simpleType> <LBRACK ";
		$$->set(str+"<expression> RBRACK>+");
		$$=errorCheck($$);
	}
	| NEW INTTYPE bracketexps multibrackets {
		$$=new Node($3, $4);
		$$->set("<newExpression> -> NEW <simpleType> ");
		$$=errorCheck($$);
	}
	| NEW id bracketexps multibrackets {
		$$=new Node($3, $2, $4);
		$$->set("<newExpression> -> NEW <simpleType> ");
		$$=errorCheck($$);
	}
	| error id LPAREN arglst RPAREN {
			printError("Expected \'new\'");
			$$=new NodeERROR();
	}
	/*
	| NEW id error arglst RPAREN {
			printError("Expected \'(\'");
			$$=new NodeERROR();
	}*/
;
bracketexps: bracketexps bracketexp {
		Node* p=$1;
		if(p->getNext()) {
			p->getNext();//this could be nullptr hence the if
			while(p->getNext()) {
				p=p->getNext();
			}
			p->setNext($2);
		}
		else {
			p->setNext($2);
		}
	}
	| bracketexp {
		$$=$1;
	}
;
bracketexp: LBRACK exp RBRACK {
		$$=new NodeNOSPACE($2);
		$$->set("<LBRACK <exp> RBRACK>");
		$$=errorCheck($$);
	}
;
multibrackets: multibrackets multibracket {
		Node* p=$1;
		if(p->getNext()) {
			//p->getNext();//this could be nullptr hence the if
			while(p->getNext()) {
				p=p->getNext();
			}
			p->setNext($2);
		}
		else {
			p->setNext($2);
		}
	}
	| multibracket {
		$$=$1;
	}
;
multibracket: LBRACK RBRACK {
		$$=new NodeNOSPACE();
		$$->set("<LBRACK RBRACK>");
	  symbol->dims++;
		$$=errorCheck($$);
	}
;

exp: name {
		$$=new Node($1);
		$$->set("<exp> -> <name>");
		$$=errorCheck($$);
	}
	| INT {
		const char* tmp=scanner.YYText();
		$$=new Node(new NodeINT(atoi(tmp)));
		$$->set("<exp> -> NUMBER");
		$$=errorCheck($$);
	}
	| NUL {
			$$=new Node();
			$$->set("<exp> -> null");
		}
	| READ LPAREN RPAREN {
			$$=new Node();
			$$->set("<exp> -> READ LPAREN RPAREN");
		}
	| name LPAREN arglst RPAREN {
		$$=new Node($1, $3);
		$$->set("<expression> -> <name> LPAREN <argList> RPAREN");
		$$=errorCheck($$);
	}
	| newexp {
		$$=new Node($1);
		$$->set("<expression> -> <newExpression>");
		$$=errorCheck($$);
	}
	| MINUS exp %prec UMINUS{
		$$=new Node($2);
		$$->set("<expression> -> MINUS <expression>");
		$$=errorCheck($$);
	}
	| PLUS exp %prec UMINUS{
		$$=new Node($2);
		$$->set("<expression> -> PLUS <expression>");
		$$=errorCheck($$);
	}
	| NOT exp %prec UMINUS {
		$$=new Node($2);
		$$->set("<expression> -> NOT <expression>");
		$$=errorCheck($$);
	}
	| exp NEQ exp {
		$$=new Node($1, $3);
		$$->set("<expression> -> <expression> NEQ <expression>");
		$$=errorCheck($$);
	}
	| exp EQ exp {
		$$=new Node($1, $3);
		$$->set("<expression> -> <expression> EQ <expression>");
		$$=errorCheck($$);
	}
	| exp LEQ exp {
		$$=new Node($1, $3);
		$$->set("<expression> -> <expression> LEQ <expression>");
		$$=errorCheck($$);
	}
	| exp GEQ exp {
		$$=new Node($1, $3);
		$$->set("<expression> -> <expression> GEQ <expression>");
		$$=errorCheck($$);
	}
	| exp LT exp {
		$$=new Node($1, $3);
		$$->set("<expression> -> <expression> LT <expression>");
		$$=errorCheck($$);
	}
	| exp GT exp {
		$$=new Node($1, $3);
		$$->set("<expression> -> <expression> GT <expression>");
		$$=errorCheck($$);
	}
	| exp AND exp {
		$$=new Node($1, $3);
		$$->set("<expression> -> <expression> AND <expression>");
		$$=errorCheck($$);
	}
	| exp OR exp {
		$$=new Node($1, $3);
		$$->set("<expression> -> <expression> OR <expression>");
		$$=errorCheck($$);
	}
	| exp PLUS exp {
		$$=new Node($1, $3);
		$$->set("<expression> -> <expression> PLUS <expression>");
		$$=errorCheck($$);
	}
	| exp MINUS exp {
		$$=new Node($1, $3);
		$$->set("<expression> -> <expression> MINUS <expression>");
		$$=errorCheck($$);
	}
	| exp TIMES exp {
		$$=new Node($1, $3);
		$$->set("<expression> -> <expression> TIMES <expression>");
		$$=errorCheck($$);
	}
	| exp DIV exp {
		$$=new Node($1, $3);
		$$->set("<expression> -> <expression> DIV <expression>");
		$$=errorCheck($$);
	}
	| exp MOD exp {
		$$=new Node($1, $3);
		$$->set("<expression> -> <expression> MOD <expression>");
		$$=errorCheck($$);
	}
	| LPAREN exp RPAREN {
		$$=new Node($2);
		$$->set("<exp> -> ( <exp> )");
		$$=errorCheck($$);
	}
;

type: INTTYPE {
		$$=new Node();
		$$->set("<type> -> INT");
		if(symbol) {
      symbol->type="int";
		}
		else {
      symbol=new Entry();
      symbol->id="int";
      symbol->type=symbol->id;
		}
		//$$->entry=symbol;
		$$=errorCheck($$);
	}
  | id {
		$$=new Node($1);
		symbol->type=symbol->id;
		//$$->entry=$1->entry;
		$$->set("<type> -> ID");
		$$=errorCheck($$);
	}
;

id: IDENT {
		$$=new Node();
		string tmp=scanner.YYText();
		//its some sort of type or something, because the symbol hasnt been cleared
		if(symbol) {
      symbol->id=tmp;
		}
		else {
      symbol=new Entry();
      symbol->id=tmp;
		}
		if(table) {
      //already exists dont overwrite it
		}
		else {
      table=new SymbolTable(super);
      table->id=tmp;
		}
/*		$$->entry=new Entry();
		$$->entry->id=symbol->id;
		$$->entry->type=symbol->type;
		$$->table=table;*/
		tmp="ID -> "+tmp;
		$$->set(tmp);
	}
;
%%
